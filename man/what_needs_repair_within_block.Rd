% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/repair.R
\name{what_needs_repair_within_block}
\alias{what_needs_repair_within_block}
\title{A helper function that updates the \code{repair_status} of building components in a block.}
\usage{
what_needs_repair_within_block(block_tibble, per_block_spend)
}
\arguments{
\item{block_tibble}{a block dataframe or tibble with a \code{costs}variable.}

\item{per_block_spend}{a scalar calculated from \code{repair_monies} / number of blocks.}
}
\value{
A \code{block_tibble} that has had building components ready to be
 repaired or not indicated
by the new variable \code{repair_status}.
}
\description{
Outputs a block_tibble after spending \code{per_block_spend} on one block. Used in the 
\code{\link{repair}} function. A new binary variable is created of the \code{repair_status} 
of each building component within the block (later dropped in the \code{\link{repair}} function).
 The building components are sorted by 
descending grade and then descending cost in the \code{\link{repair}} function prior to 
being passed to this helper function.
}
\details{
This function works by first checking if there's anything to repair in the block. If not,
it returns the input argument \code{block_tibble}. Only building components of \code{grade} 
B, C or D are considered for repair. If a building component has a repair cost of zero
it is also ignored for repair (these two logical tests are applied using an "OR"). As the
passed tibble would have been sorted by grade and then cost the function proceeds through
the sorted dataframe repairing what building components it can until all the money is spent. 
Money is divided evenly between each \code{buildingid} or block based on the \code{\link{repair}} function.
}
\examples{

example <- what_needs_repair_within_block(
tibble::tibble(cost = seq(from = 0, to = 4500, by = 500),
               grade = c("A", "B", "C", "D", "E", "B", "C", "N", "D", "B")),
               1e4)$repair_status
               
}
